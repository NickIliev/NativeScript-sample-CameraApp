var data_observable = require("data/observable");
var Observable = data_observable.Observable;
var runloop = CFRunLoopGetCurrent();
var defaultRunLoopMode = NSString.stringWithString(kCFRunLoopCommonModes);
function invokeOnMainRunLoop(func) {
    CFRunLoopPerformBlock(runloop, defaultRunLoopMode, func);
    CFRunLoopWakeUp(runloop);
}
var SessionDelegate = NSObject.extend({
    URLSessionDidBecomeInvalidWithError: function (session, error) {
    },
    URLSessionDidReceiveChallengeCompletionHandler: function (session, challenge, comlpetionHandler) {
        var disposition = null;
        var credential = null;
        comlpetionHandler(disposition, credential);
    },
    URLSessionDidFinishEventsForBackgroundURLSession: function (session) {
    },
    URLSessionTaskDidCompleteWithError: function (session, nsTask, error) {
        var jsTask = getTask(session, nsTask);
        if (error) {
            jsTask.set("status", "error");
            jsTask.notify({ eventName: "error", object: jsTask, error: error });
        }
        else {
            jsTask.set("upload", nsTask.countOfBytesSent);
            jsTask.set("totalUpload", nsTask.countOfBytesExpectedToSend);
            jsTask.set("status", "complete");
            jsTask.notify({ eventName: "progress", object: jsTask, currentBytes: nsTask.countOfBytesSent, totalBytes: nsTask.countOfBytesExpectedToSend });
            jsTask.notify({ eventName: "complete", object: jsTask });
        }
    },
    URLSessionTaskDidReceiveChallengeCompletionHandler: function (session, task, challenge, completionHandler) {
        var disposition = null;
        var credential = null;
        completionHandler(disposition, credential);
    },
    URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend: function (session, task, data, sent, expectedTotal) {
        invokeOnMainRunLoop(function () {
            var jsTask = getTask(session, task);
            jsTask.set("totalUpload", expectedTotal);
            jsTask.set("upload", sent);
            jsTask.set("status", "uploading");
            jsTask.notify({ eventName: "progress", object: jsTask, currentBytes: sent, totalBytes: expectedTotal });
        });
    },
    URLSessionTaskNeedNewBodyStream: function (session, task, need) {
    },
    URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler: function (session, task, redirect, request, completionHandler) {
        completionHandler(request);
    },
    URLSessionDataTaskDidReceiveResponseCompletionHandler: function (session, dataTask, response, completionHandler) {
        var disposition = null;
        completionHandler(disposition);
    },
    URLSessionDataTaskDidBecomeDownloadTask: function (session, dataTask, downloadTask) {
    },
    URLSessionDataTaskDidReceiveData: function (session, dataTask, data) {
    },
    URLSessionDataTaskWillCacheResponseCompletionHandler: function () {
    },
    URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes: function (session, task, offset, expects) {
    },
    URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite: function (session, task, data, written, expected) {
    },
    URLSessionDownloadTaskDidFinishDownloadingToURL: function (session, task, url) {
    }
}, {
    name: "BackgroundUploadDelegate",
    protocols: [
        NSURLSessionDelegate,
        NSURLSessionTaskDelegate,
        NSURLSessionDataDelegate,
        NSURLSessionDownloadDelegate
    ]
});
var sessions = {};
function session(id) {
    var jsSession = sessions[id];
    if (jsSession) {
        return jsSession;
    }
    var delegate = SessionDelegate.alloc().init();
    var configuration = NSURLSessionConfiguration.backgroundSessionConfigurationWithIdentifier(id);
    var session = NSURLSession.sessionWithConfigurationDelegateDelegateQueue(configuration, delegate, null);
    function uploadFile(fileUri, options) {
        var url = NSURL.URLWithString(options.url);
        var request = NSMutableURLRequest.requestWithURL(url);
        var headers = options.headers;
        if (headers) {
            for (var header in headers) {
                var value = headers[header];
                if (value !== null && value !== void 0) {
                    request.setValueForHTTPHeaderField(value.toString(), header);
                }
            }
        }
        if (options.method) {
            request.HTTPMethod = options.method;
        }
        var file = NSURL.URLWithString(fileUri);
        var newTask = session.uploadTaskWithRequestFromFile(request, file);
        newTask.taskDescription = options.description;
        newTask.resume();
        return getTask(session, newTask);
    }
    jsSession = new Observable();
    jsSession.set("ios", session);
    jsSession.set("uploadFile", uploadFile);
    sessions[id] = jsSession;
    return jsSession;
}
exports.session = session;
var tasks = new WeakMap();
function getTask(nsSession, nsTask) {
    var jsTask = tasks.get(nsTask);
    if (jsTask) {
        return jsTask;
    }
    jsTask = new Observable();
    jsTask.set("ios", nsTask);
    jsTask.set("session", nsSession);
    jsTask.set("description", nsTask.taskDescription);
    jsTask.set("upload", nsTask.countOfBytesSent);
    jsTask.set("totalUpload", nsTask.countOfBytesExpectedToSend);
    if (nsTask.error) {
        jsTask.set("status", "error");
    }
    else {
        if (nsTask.state == NSURLSessionTaskState.NSURLSessionTaskStateRunning) {
            jsTask.set("status", "uploading");
        }
        else if (nsTask.state == NSURLSessionTaskState.NSURLSessionTaskStateCompleted) {
            jsTask.set("status", "complete");
        }
        else if (nsTask.state == NSURLSessionTaskState.NSURLSessionTaskStateCanceling) {
            jsTask.set("status", "error");
        }
        else if (nsTask.state == NSURLSessionTaskState.NSURLSessionTaskStateSuspended) {
            jsTask.set("status", "pending");
        }
    }
    tasks.set(nsTask, jsTask);
    return jsTask;
}
